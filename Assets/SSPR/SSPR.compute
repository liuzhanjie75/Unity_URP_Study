#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

#pragma kernel SSPR

RWTexture2D<half4> _SSPRReflectionTexture;

Texture2D<float4> _CameraColorTexture;
Texture2D<float4> _CameraDepthTexture;

SAMPLER(sampler_CameraDepthTexture);
SAMPLER(sampler_CameraColorTexture);

float4 _SSPRReflectionSize;
float _ReflectPlaneHeight;

[numthreads(8,8,1)]
void SSPR(uint3 id : SV_DispatchThreadID)
{
    _SSPRReflectionTexture[id.xy] = half4(0.0, 0.0, 0.0, 0.0);
    // 计算屏幕uv DispatchThreadID：当前线程组在所有线程组里的ID，即图像pos
    float2 uv = id.xy * _SSPRReflectionSize.zw;
    float depth = _CameraDepthTexture.SampleLevel(sampler_CameraDepthTexture, uv, 0).r;

    // 根据深度还原世界坐标
    float3 wpos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);
    // 舍去那些在平面下方的像素
    if (wpos.y < _ReflectPlaneHeight) return;

    // 计算反射后的世界坐标
    float3 rwpos = wpos;
    rwpos.y = -rwpos.y + 2 * _ReflectPlaneHeight;

    // 计算反射后的uv
    float4 rcpos = TransformWorldToHClip(rwpos);
    float2 ruv = float2(rcpos.x, rcpos.y * _ProjectionParams.x) * rcp(rcpos.w) * 0.5 + 0.5;
    if (any(ruv) < 0.0 || any(ruv) > 1.0) return;

    // 计算反射后的索引
    float2 ridx = ruv * _SSPRReflectionSize.xy;

    half4 color = _CameraColorTexture.SampleLevel(sampler_CameraColorTexture, uv, 0);

    _SSPRReflectionTexture[ridx] = color;
}
